{
  "master": {
    "tasks": [
      {
        "id": 11,
        "title": "CLI 기본 구조 및 명령어 파서 구축",
        "description": "vitnal-start-kit CLI의 기본 골격을 설정하고 'create <project-name>' 명령어를 처리할 수 있는 파서를 구현합니다. 이 작업은 전체 CLI 애플리케이션의 진입점을 마련하는 첫 단계입니다.",
        "details": "Node.js 환경에서 실행되는 CLI를 구축하기 위해 `commander.js` 라이브러리를 사용합니다. `package.json`의 `bin` 필드에 'create-vitnal' 명령어를 등록하여 전역적으로 실행할 수 있게 설정합니다. `program.argument('<project-name>', '...')`를 사용하여 프로젝트 이름을 인자로 받고, `.action((projectName) => { ... })` 콜백 내에서 후속 로직을 트리거하는 기본 구조를 완성합니다.",
        "testStrategy": "유닛 테스트를 통해 `process.argv`를 모의(mock)하여 다양한 명령어와 인자(예: 'create my-app', 'create')가 정확하게 파싱되는지 검증합니다. 프로젝트 이름이 누락되었을 때 적절한 오류 메시지를 표시하는지도 확인합니다.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "package.json에 commander.js 의존성 추가",
            "description": "CLI 명령어 파싱을 위해 commander.js 라이브러리를 프로젝트의 의존성으로 추가합니다. 이는 명령어 기반 인터페이스를 구축하는 첫 단계입니다.",
            "dependencies": [],
            "details": "`npm install commander` 또는 `yarn add commander` 명령어를 실행하여 `package.json`의 `dependencies`에 `commander`를 추가합니다. 최신 안정 버전을 사용하는 것을 권장합니다.",
            "status": "done",
            "testStrategy": "`package.json` 파일을 열어 `dependencies` 항목에 `commander`가 정상적으로 추가되었는지 확인하고, `node_modules` 디렉터리에 해당 패키지가 설치되었는지 검사합니다."
          },
          {
            "id": 2,
            "title": "package.json에 bin 필드 설정 및 CLI 진입점 파일 생성",
            "description": "터미널에서 'create-vitnal' 명령어를 통해 CLI를 실행할 수 있도록 `package.json`에 `bin` 필드를 설정하고, 명령어 실행 시 호출될 진입점 스크립트 파일을 생성합니다.",
            "dependencies": [
              1
            ],
            "details": "`package.json`에 `\"bin\": { \"create-vitnal\": \"./cli.js\" }` 와 같이 `bin` 필드를 추가합니다. 프로젝트 루트에 `cli.js` 파일을 생성하고, 파일 최상단에 `#!/usr/bin/env node` shebang을 반드시 추가해야 합니다.\n<info added on 2025-11-11T14:59:20.708Z>\n```json\n\"TypeScript 기반 CLI를 위해 `package.json`의 `bin` 필드를 빌드 산출물 경로인 `\\\"bin\\\": { \\\"create-vitnal\\\": \\\"dist/cli.js\\\" }`로 설정합니다. 소스 진입점은 `src/cli.ts`로 생성하며, 파일 최상단에 `#!/usr/bin/env node` shebang을 추가합니다. TypeScript 컴파일 시 shebang이 유지되도록 `tsconfig.json`의 `outDir` 설정을 확인해야 합니다. `src/cli.ts`에는 향후 Commander 로직을 담을 기본 골격(예: TODO 주석)을 작성합니다. `npm run build` 실행 시 `dist/cli.js`가 생성되어 `bin` 경로와 연결됩니다.\\n\\n테스트 방법: `npm run build`를 실행하여 빌드한 후 `npm link`를 실행하고, 터미널에서 `create-vitnal` 명령이 동작하는지 확인합니다.\"\n```\n</info added on 2025-11-11T14:59:20.708Z>",
            "status": "done",
            "testStrategy": "프로젝트 루트에서 `npm link` 명령어를 실행하여 로컬 개발 환경에 명령어를 등록합니다. 그 후 터미널에서 `create-vitnal`을 입력했을 때, 오류 없이 (혹은 파일이 비어있어 아무 동작 없이) 명령어가 인식되는지 확인합니다."
          },
          {
            "id": 3,
            "title": "commander를 사용한 기본 프로그램 구조 및 버전 설정",
            "description": "생성된 `cli.js` 파일에서 `commander`를 가져와 기본 프로그램 인스턴스를 생성합니다. `--version`과 `--help` 같은 기본 옵션이 동작하도록 버전과 설명을 설정합니다.",
            "dependencies": [
              2
            ],
            "details": "`cli.js` 파일에 `const { program } = require('commander');` 코드를 추가합니다. `program.version('0.1.0').description('A CLI for creating Vitnal projects');` 와 같이 프로그램의 초기 버전과 설명을 설정합니다.",
            "status": "done",
            "testStrategy": "터미널에서 `create-vitnal --version` 명령어를 실행했을 때 설정한 버전(예: '0.1.0')이 출력되는지 확인합니다. 또한 `create-vitnal --help`를 실행했을 때 설정한 설명이 출력되는지 검증합니다."
          },
          {
            "id": 4,
            "title": "'create <project-name>' 명령어 및 인자 정의",
            "description": "CLI의 핵심 기능인 'create' 명령어를 정의하고, 필수 인자로 생성할 프로젝트의 이름(`<project-name>`)을 받도록 설정합니다. 이는 사용자가 새 프로젝트를 생성할 때 사용할 기본 구문입니다.",
            "dependencies": [
              3
            ],
            "details": "`cli.js` 파일에서 `program.command('create')` 메서드를 사용하여 새 명령어를 등록합니다. 이어서 `.argument('<project-name>', 'The name of the project to create')`를 체이닝하여 필수 인자를 정의합니다.",
            "status": "done",
            "testStrategy": "터미널에서 `create-vitnal create` 와 같이 프로젝트 이름을 빼고 명령어를 실행했을 때, `commander`가 자동으로 생성하는 'error: missing required argument 'project-name'' 메시지가 표시되는지 확인합니다."
          },
          {
            "id": 5,
            "title": "'create' 명령어 액션 핸들러 구현 및 인자 파싱 실행",
            "description": "'create' 명령어가 실행되었을 때 수행될 로직을 담는 액션 핸들러를 구현합니다. 핸들러 내에서 입력받은 프로젝트 이름을 간단히 출력하여 인자 전달을 확인하고, CLI 인자 파싱을 최종적으로 실행시킵니다.",
            "dependencies": [
              4
            ],
            "details": "`.argument()` 뒤에 `.action((projectName) => { console.log(`Project directory '${projectName}' will be created.`); })`를 추가하여 액션 핸들러를 구현합니다. 스크립트의 마지막 줄에 `program.parse(process.argv);`를 추가하여 전체 프로세스를 실행합니다.",
            "status": "done",
            "testStrategy": "터미널에서 `create-vitnal create my-new-app` 명령어를 실행했을 때, 콘솔에 \"Project directory 'my-new-app' will be created.\" 메시지가 정확하게 출력되는지 확인하여 명령어와 액션이 올바르게 연결되었는지 검증합니다."
          }
        ]
      },
      {
        "id": 12,
        "title": "기본 React + TypeScript 템플릿 구성",
        "description": "Vite 기반의 React, TypeScript, TailwindCSS, Vitest, Storybook이 포함된 핵심 템플릿을 생성합니다. 이 템플릿은 모든 프로젝트 생성의 기반이 됩니다.",
        "details": "프로젝트 내에 'templates/base' 디렉터리를 생성하고, `npm create vite@latest`를 통해 React + TypeScript 프로젝트를 초기화합니다. 그 후 `tailwindcss`, `vitest`, `storybook`을 추가로 설치하고 각각의 설정 파일(`tailwind.config.js`, `vitest.config.ts`, `.storybook/`)을 구성합니다. 모든 개발 의존성은 템플릿의 `package.json`에 포함시킵니다.",
        "testStrategy": "구성된 'templates/base' 디렉터리 내에서 직접 `npm install`과 `npm run build`를 실행하여 템플릿 자체가 오류 없이 빌드되는지 확인합니다. 또한 `npm run test`와 `npm run storybook`이 정상적으로 실행되는지 검증합니다.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "`templates/base` 디렉터리 생성 및 Vite React-TS 프로젝트 초기화",
            "description": "Vite CLI를 사용하여 `templates/base` 경로에 기본적인 React + TypeScript 프로젝트를 생성합니다. 이는 모든 추가 기능의 기반이 됩니다.",
            "dependencies": [],
            "details": "프로젝트 루트에 `templates/base` 디렉터리를 생성합니다. 그 후 해당 디렉터리 내에서 `npm create vite@latest . -- --template react-ts` 명령을 실행하여 Vite 프로젝트를 초기화합니다. 이 때, 프로젝트 이름 프롬프트는 현재 디렉터리를 의미하는 `.`으로 지정합니다.",
            "status": "done",
            "testStrategy": "`templates/base` 디렉터리 내에 `vite.config.ts`, `package.json`, `src/main.tsx` 등의 기본 Vite 프로젝트 파일들이 정상적으로 생성되었는지 확인합니다."
          },
          {
            "id": 2,
            "title": "TailwindCSS 설치 및 기본 설정",
            "description": "생성된 Vite 프로젝트에 TailwindCSS를 추가하고, `tailwind.config.js`와 `postcss.config.js`를 설정하여 전역 스타일링을 준비합니다.",
            "dependencies": [
              1
            ],
            "details": "`templates/base` 디렉터리에서 `npm install -D tailwindcss postcss autoprefixer`를 실행하고, `npx tailwindcss init -p` 명령어로 설정 파일을 생성합니다. `tailwind.config.js`의 `content` 속성에 `\"./src/**/*.{js,ts,jsx,tsx}\"` 경로를 추가하고, `src/index.css` 파일에 Tailwind의 `@tailwind` 지시문을 추가합니다.",
            "status": "done",
            "testStrategy": "간단한 TailwindCSS 클래스(예: `text-red-500`)를 `src/App.tsx`에 적용한 후 `npm run dev`를 실행하여 스타일이 올바르게 적용되는지 브라우저에서 확인합니다."
          },
          {
            "id": 3,
            "title": "Vitest 설치 및 테스트 환경 구성",
            "description": "유닛 및 컴포넌트 테스트를 위해 Vitest를 설치하고, Vite 설정 파일과 연동하여 테스트 실행 환경을 구축합니다.",
            "dependencies": [
              1
            ],
            "details": "`templates/base` 디렉터리에서 `npm install -D vitest @vitest/ui jsdom @testing-library/react`를 실행합니다. `vite.config.ts` 파일을 수정하여 테스트 관련 설정을 추가합니다. `package.json`의 `scripts` 객체에 `\"test\": \"vitest\"`와 `\"test:ui\": \"vitest --ui\"`를 추가합니다.",
            "status": "done",
            "testStrategy": "기본 `App` 컴포넌트를 렌더링하고 특정 텍스트가 존재하는지 확인하는 간단한 테스트 파일(`src/App.test.tsx`)을 작성한 뒤, `npm run test`를 실행하여 테스트가 성공적으로 통과하는지 확인합니다."
          },
          {
            "id": 4,
            "title": "Storybook 설치 및 초기 설정",
            "description": "컴포넌트 기반 개발 및 시각적 문서화를 위해 Storybook을 프로젝트에 통합하고 기본 설정을 완료합니다.",
            "dependencies": [
              1
            ],
            "details": "`templates/base` 디렉터리에서 `npx storybook@latest init` 명령을 실행하여 Storybook을 자동으로 설치 및 구성합니다. 이 과정에서 `.storybook` 디렉터리와 관련 설정 파일(`main.ts`, `preview.ts`)이 생성됩니다. `tailwind.config.js`를 인식하도록 `.storybook/preview.ts`에 `import '../src/index.css';`를 추가합니다.",
            "status": "done",
            "testStrategy": "`npm run storybook` 명령어를 실행하여 Storybook 개발 서버가 정상적으로 구동되는지 확인합니다. 브라우저에서 Storybook UI가 나타나고, TailwindCSS 스타일이 적용된 기본 버튼 스토리가 올바르게 렌더링되는지 검증합니다."
          },
          {
            "id": 5,
            "title": "템플릿 정리 및 최종 검증",
            "description": "초기화 과정에서 생성된 불필요한 파일들을 제거하고, 모든 도구가 통합된 상태에서 빌드 및 테스트가 정상 동작하는지 최종 확인합니다.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Vite와 Storybook이 생성한 예제 파일들(예: `src/assets`, `src/App.css`, `src/components/`, `src/stories/`)을 삭제합니다. `App.tsx`의 내용을 최소한의 기본 구조로 정리합니다. 최종적으로 `templates/base` 디렉터리에서 `npm install`을 실행한 후 `npm run build`, `npm run test`가 모두 오류 없이 완료되는지 확인합니다.",
            "status": "done",
            "testStrategy": "정리된 `templates/base` 디렉터리에서 `npm install` 후 `npm run build`, `npm run test`, `npm run storybook` 스크립트가 모두 정상적으로 실행되는지 확인하여 템플릿의 무결성을 검증합니다."
          }
        ]
      },
      {
        "id": 13,
        "title": "템플릿 복제 및 파일 시스템 제어 로직 구현",
        "description": "지정된 템플릿 소스('templates/base')에서 사용자가 입력한 프로젝트 이름의 대상 디렉터리로 파일과 폴더를 복제하는 기능을 구현합니다.",
        "details": "Node.js 내장 `fs` 모듈의 `cp` 함수나, 더 강력한 오류 처리와 편의성을 제공하는 `fs-extra` 라이브러리의 `copy` 함수를 사용합니다. 대상 디렉터리가 이미 존재하는 경우와 같은 예외 상황을 처리하는 로직을 포함해야 합니다. 파일 복사 진행 상황을 사용자에게 보여주기 위한 로깅 유틸리티를 연동합니다.",
        "testStrategy": "테스트 실행 시 임시 디렉터리를 생성하고, 템플릿 복제 함수를 실행한 뒤 원본 템플릿과 복사된 결과물의 파일 및 폴더 구조가 일치하는지 재귀적으로 비교하여 검증합니다. 특정 파일을 복사에서 제외하는 `.gitignore`와 유사한 기능도 테스트합니다.",
        "priority": "high",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "'fs-extra' 의존성 추가 및 타입 정의 설치",
            "description": "템플릿 파일 및 디렉터리를 안정적으로 복사하기 위해 'fs-extra' 라이브러리를 프로젝트 의존성에 추가하고, TypeScript 지원을 위한 '@types/fs-extra' 개발 의존성을 설치합니다.",
            "dependencies": [],
            "details": "터미널에서 `npm install fs-extra`와 `npm install @types/fs-extra --save-dev` 명령어를 실행하여 의존성을 `package.json` 파일에 추가하고 `package-lock.json`을 업데이트합니다.",
            "status": "pending",
            "testStrategy": "`node_modules` 디렉터리에서 `fs-extra` 폴더의 존재 여부와 `package.json` 파일 내의 `dependencies` 및 `devDependencies` 목록에 해당 항목이 추가되었는지 확인합니다."
          },
          {
            "id": 2,
            "title": "기본 템플릿 복제 유틸리티 함수 구현",
            "description": "'fs-extra'의 `copy` 함수를 사용하여 지정된 소스 경로의 템플릿을 대상 경로로 복사하는 핵심 유틸리티 함수를 작성합니다. 이 함수는 비동기로 동작해야 합니다.",
            "dependencies": [
              1
            ],
            "details": "`src/utils/fileSystem.ts` 파일을 생성하고 `copyTemplate(source: string, destination: string): Promise<void>` 시그니처를 가진 비동기 함수를 구현합니다. 내부적으로 `fse.copy(source, destination)`을 호출하여 파일 시스템 복사를 수행합니다.",
            "status": "pending",
            "testStrategy": "Jest와 같은 테스트 프레임워크를 사용하여 임시 소스 디렉터리와 빈 대상 디렉터리를 설정합니다. `copyTemplate` 함수를 실행한 후, 대상 디렉터리의 내용이 소스 디렉터리와 일치하는지 확인합니다."
          },
          {
            "id": 3,
            "title": "대상 디렉터리 존재 여부 확인 및 예외 처리 로직 추가",
            "description": "템플릿을 복사하기 전에 대상 디렉터리가 이미 존재하는지 확인하는 로직을 추가합니다. 만약 디렉터리가 존재하고 비어있지 않다면, 오류를 발생시켜 의도치 않은 덮어쓰기를 방지합니다.",
            "dependencies": [
              2
            ],
            "details": "`copyTemplate` 함수 시작 부분에 `fse.pathExists(destination)`과 `fse.readdir(destination)`을 사용하여 대상 디렉터리의 상태를 확인합니다. 디렉터리가 존재하고 파일이 하나 이상 있을 경우, 'Destination directory is not empty.'와 같은 명확한 오류 메시지와 함께 Promise를 reject하도록 수정합니다.",
            "status": "pending",
            "testStrategy": "미리 파일을 포함하는 디렉터리를 생성하고, 해당 디렉터리를 복사 대상으로 지정하여 `copyTemplate` 함수를 실행했을 때 예상된 오류가 발생하는지 테스트 케이스를 작성하여 검증합니다."
          },
          {
            "id": 4,
            "title": "로깅 유틸리티를 사용한 복사 진행 상황 피드백 구현",
            "description": "기존에 구현된 로깅 유틸리티(e.g., `src/utils/logger.ts`)를 연동하여 파일 복사 작업의 시작과 완료, 그리고 오류 발생 시 사용자에게 명확한 피드백을 제공합니다.",
            "dependencies": [
              3
            ],
            "details": "`copyTemplate` 함수 실행 전후와 catch 블록에 로깅 함수를 추가합니다. `logger.info('Copying template files...')`와 같은 메시지를 시작 시점에 출력하고, `try-catch` 구문을 사용하여 작업 완료 시 `logger.success('Template copied successfully!')`, 실패 시 `logger.error(error.message)`를 출력하도록 구현합니다. 스피너 로거가 있다면 이를 활용하여 진행 중 상태를 표시합니다.",
            "status": "pending",
            "testStrategy": "콘솔 출력을 가로채거나 모의(mock) 로거를 주입하여, `copyTemplate` 함수의 각 시나리오(성공, 실패)에 따라 정확한 메시지가 올바른 로그 레벨(info, success, error)로 출력되는지 확인합니다."
          },
          {
            "id": 5,
            "title": "프로젝트 생성 로직에 템플릿 복제 기능 통합",
            "description": "사용자로부터 프로젝트 이름을 입력받는 메인 CLI 로직에서 새로 구현한 `copyTemplate` 함수를 호출하여 전체 프로젝트 생성 플로우를 완성합니다.",
            "dependencies": [
              4
            ],
            "details": "프로젝트 생성 과정을 담당하는 `src/core/creator.ts` 또는 유사 파일에서 사용자가 입력한 프로젝트 이름을 기반으로 대상 경로를 설정합니다. 그런 다음, `templates/base`를 소스 경로로, 계산된 대상 경로를 목적지로 하여 `copyTemplate(templatePath, targetPath)` 함수를 호출합니다.",
            "status": "pending",
            "testStrategy": "전체 CLI 애플리케이션을 실행하는 엔드투엔드(E2E) 테스트를 작성합니다. 특정 프로젝트 이름을 입력하고 명령을 실행한 후, 파일 시스템에 해당 이름의 디렉터리가 생성되고 그 안에 `templates/base`의 내용이 정확히 복제되었는지 확인합니다."
          }
        ]
      },
      {
        "id": 14,
        "title": "대화형 옵션 프롬프트 구현",
        "description": "사용자에게 서버 상태 관리(react-query), 상태 관리(jotai, zustand), Taskmaster 설치 여부 등 주요 옵션을 선택받기 위한 대화형 프롬프트를 구현합니다.",
        "details": "`inquirer` 라이브러리를 사용하여 CLI에서 대화형 질문을 표시합니다. 각 질문은 `type: 'confirm'` 또는 `type: 'list'`를 사용하며, PRD에 명시된 대로 기본값을 제공하여 사용자가 빠르게 진행할 수 있도록 합니다(예: react-query: Yes, Taskmaster: Yes). 사용자의 선택은 하나의 설정 객체로 취합하여 후속 작업에 전달합니다.",
        "testStrategy": "`inquirer`를 모의(mock)하여, 사전에 정의된 답변 배열을 입력했을 때 올바른 설정 객체가 반환되는지 확인하는 유닛 테스트를 작성합니다. 각 프롬프트의 질문 메시지와 선택지가 명확하게 표시되는지 수동으로 검증합니다.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "`inquirer` 의존성 추가 및 옵션 타입 정의",
            "description": "프로젝트에 `inquirer` 라이브러리를 설치하고, 대화형 프롬프트로부터 수집할 사용자 설정 옵션에 대한 TypeScript 인터페이스를 정의합니다.",
            "dependencies": [],
            "details": "`pnpm add -D inquirer @types/inquirer` 명령을 실행하여 의존성을 추가합니다. `src/types` 디렉터리 내에 `options.ts` 파일을 생성하고 `ProjectOptions` 인터페이스를 정의합니다. 이 인터페이스에는 `reactQuery: boolean`, `stateManagement: 'jotai' | 'zustand' | 'none'`, `taskmaster: boolean`과 같은 필드가 포함되어야 합니다.",
            "status": "pending",
            "testStrategy": "`package.json`에 `inquirer`와 `@types/inquirer`가 `devDependencies`로 추가되었는지 확인합니다. `ProjectOptions` 인터페이스가 지정된 필드와 타입으로 올바르게 정의되었는지 코드 검토를 통해 확인합니다."
          },
          {
            "id": 2,
            "title": "서버 상태 관리(React Query) 질문 프롬프트 구현",
            "description": "사용자에게 React Query 설치 여부를 묻는 'confirm' 타입의 대화형 질문을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "`src/lib/prompts.ts` 파일에 `inquirer.prompt`를 사용하는 함수를 작성합니다. 질문 객체는 `{ type: 'confirm', name: 'reactQuery', message: 'React Query를 사용하여 서버 상태를 관리하시겠습니까?', default: true }`와 같이 구성합니다.",
            "status": "pending",
            "testStrategy": "해당 프롬프트 함수를 직접 실행하여 CLI에 질문이 올바르게 표시되고 기본값이 'Yes'로 설정되어 있는지 수동으로 확인합니다. Enter 키를 눌렀을 때 `true`가 반환되는지 확인합니다."
          },
          {
            "id": 3,
            "title": "클라이언트 상태 관리(Jotai, Zustand) 질문 프롬프트 구현",
            "description": "사용자에게 Jotai, Zustand 중 하나를 선택하거나, 아무것도 선택하지 않을 수 있는 'list' 타입의 대화형 질문을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "`src/lib/prompts.ts` 파일에 `inquirer.prompt`를 사용하는 질문을 추가합니다. 질문 객체는 `{ type: 'list', name: 'stateManagement', message: '어떤 클라이언트 상태 관리 라이브러리를 사용하시겠습니까?', choices: ['Jotai', 'Zustand', 'None'], default: 'None' }` 형식으로 구성합니다. 답변은 후처리를 위해 소문자 또는 'none'으로 변환합니다.",
            "status": "pending",
            "testStrategy": "프롬프트를 실행하여 선택지(Jotai, Zustand, None)가 모두 표시되는지 확인합니다. 각 항목을 선택했을 때 해당하는 값('jotai', 'zustand', 'none')이 올바르게 반환되는지 단위 테스트 또는 수동 테스트로 검증합니다."
          },
          {
            "id": 4,
            "title": "Taskmaster 설치 여부 질문 프롬프트 구현",
            "description": "사용자에게 Taskmaster (AI 기반 작업 관리 도우미) 설치 여부를 묻는 'confirm' 타입의 대화형 질문을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "`src/lib/prompts.ts` 파일에 `{ type: 'confirm', name: 'taskmaster', message: 'Taskmaster (AI-powered task manager)를 설치하시겠습니까?', default: true }` 구성의 질문을 추가합니다. 이는 다른 'confirm' 타입 질문과 동일한 패턴을 따릅니다.",
            "status": "pending",
            "testStrategy": "CLI에서 프롬프트를 실행하여 질문 메시지와 기본값이 'Yes'로 올바르게 표시되는지 확인합니다. 'No'를 선택했을 때 `false`가 반환되는지 검증합니다."
          },
          {
            "id": 5,
            "title": "전체 프롬프트 통합 및 설정 객체 생성 함수 작성",
            "description": "개별적으로 구현된 모든 질문 프롬프트를 순차적으로 실행하고, 답변들을 하나의 `ProjectOptions` 객체로 취합하여 반환하는 메인 함수를 구현합니다.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "`src/lib/prompts.ts`에 `export async function promptForOptions(): Promise<ProjectOptions>` 함수를 정의합니다. 이 함수 내에서 이전에 만든 모든 질문 객체를 배열에 담아 `inquirer.prompt`에 전달합니다. 반환된 답변 객체를 `ProjectOptions` 타입에 맞게 가공하여 반환하고, `src/cli.ts`에서 이 함수를 호출하여 결과를 사용하도록 연결합니다.",
            "status": "pending",
            "testStrategy": "`inquirer`를 모킹(mocking)하여 사전 정의된 답변 시나리오(예: React Query: yes, Zustand, Taskmaster: no)를 입력값으로 제공했을 때, 예상되는 `ProjectOptions` 객체가 정확히 반환되는지 확인하는 단위 테스트를 작성합니다."
          }
        ]
      },
      {
        "id": 15,
        "title": "동적 의존성 설치 로직 구현",
        "description": "사용자의 옵션 선택에 따라 기본 의존성 외에 추가 패키지(예: react-query, zustand, task-master)를 동적으로 설치하는 로직을 구현합니다.",
        "details": "Node.js의 `child_process` 모듈에서 `spawn`을 사용하거나, 더 나은 프로세스 제어와 출력을 제공하는 `execa` 라이브러리를 사용하여 생성된 프로젝트 폴더 내에서 `npm install` 명령을 실행합니다. 사용자가 선택한 옵션 객체를 기반으로 설치할 패키지 목록을 동적으로 구성하고, 개발 의존성과 일반 의존성을 구분하여 설치합니다. 설치 과정을 스피너와 함께 사용자에게 시각적으로 표시합니다.",
        "testStrategy": "다양한 옵션 조합으로 프로젝트 생성을 테스트합니다. 생성 완료 후 각 경우의 `package.json` 파일을 읽어 `dependencies`와 `devDependencies`에 올바른 패키지들이 정확한 버전으로 설치되었는지 확인합니다. 설치 실패 시 적절한 오류 메시지가 출력되는지도 검증합니다.",
        "priority": "high",
        "dependencies": [
          13,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "사용자 선택 옵션과 패키지 이름 매핑 유틸리티 구현",
            "description": "사용자가 선택한 옵션(예: react-query, zustand)을 실제 npm 패키지 이름과 설치 유형(일반/개발)으로 변환하는 매핑 객체 또는 함수를 생성합니다.",
            "dependencies": [],
            "details": "`src/utils/dependencies.ts`와 같은 새 파일을 만들고, 사용자 옵션 객체를 입력받아 `{ dependencies: string[], devDependencies: string[] }` 형태의 객체를 반환하는 함수를 정의합니다. 예를 들어, `options.stateManagement === 'zustand'`이면 `dependencies` 배열에 'zustand'를 추가합니다.",
            "status": "pending",
            "testStrategy": "다양한 옵션 조합을 입력했을 때, 정확한 의존성 및 개발 의존성 패키지 목록이 반환되는지 확인하는 유닛 테스트를 작성합니다."
          },
          {
            "id": 2,
            "title": "`execa` 라이브러리 설치 및 기본 설치 함수 구조 설정",
            "description": "명령어 실행을 위해 `execa` 라이브러리를 CLI 도구의 의존성으로 추가하고, 의존성 설치를 담당할 기본 비동기 함수를 `src/core/installer.ts`에 생성합니다.",
            "dependencies": [
              1
            ],
            "details": "프로젝트 루트에서 `npm install execa`를 실행하여 의존성을 추가합니다. `src/core/installer.ts` 파일에 `installDependencies(projectPath: string, options: UserOptions)` 시그니처를 갖는 비동기 함수를 정의합니다. 이 함수는 내부적으로 1번 서브태스크에서 만든 매핑 유틸리티를 호출합니다.",
            "status": "pending",
            "testStrategy": "`execa`가 `package.json`에 추가되었는지 확인하고, `installer.ts` 파일과 `installDependencies` 함수가 정상적으로 생성되었는지 검토합니다."
          },
          {
            "id": 3,
            "title": "일반 의존성(dependencies) 동적 설치 로직 구현",
            "description": "`installDependencies` 함수 내에서 `execa`를 사용하여 일반 의존성을 설치하는 로직을 구현합니다. 패키지 목록이 비어있으면 이 단계를 건너뜁니다.",
            "dependencies": [
              2
            ],
            "details": "매핑 유틸리티에서 반환된 `dependencies` 배열을 가져옵니다. 배열에 항목이 있을 경우, `execa('npm', ['install', ...dependencies], { cwd: projectPath })`를 호출하여 패키지를 설치합니다. 설치 과정에서 발생하는 예외를 처리하는 로직을 포함합니다.",
            "status": "pending",
            "testStrategy": "특정 옵션(예: zustand)을 활성화하여 프로젝트 생성 시, 생성된 프로젝트의 `package.json` 파일에 'zustand'가 `dependencies` 항목에 추가되었는지 확인합니다."
          },
          {
            "id": 4,
            "title": "개발 의존성(devDependencies) 동적 설치 로직 구현",
            "description": "`installDependencies` 함수 내에서 `execa`를 사용하여 개발 의존성을 설치하는 로직을 구현합니다. 패키지 목록이 비어있으면 이 단계를 건너뜁니다.",
            "dependencies": [
              2
            ],
            "details": "매핑 유틸리티에서 반환된 `devDependencies` 배열을 가져옵니다. 배열에 항목이 있을 경우, `execa('npm', ['install', '-D', ...devDependencies], { cwd: projectPath })`를 호출하여 패키지를 설치합니다. 일반 의존성 설치와 마찬가지로 오류 처리 로직을 포함합니다.",
            "status": "pending",
            "testStrategy": "개발 의존성 관련 옵션(예: msw)을 활성화하여 프로젝트 생성 시, 생성된 프로젝트의 `package.json` 파일에 'msw'가 `devDependencies` 항목에 추가되었는지 확인합니다."
          },
          {
            "id": 5,
            "title": "`ora`를 이용한 설치 과정 시각적 피드백 구현",
            "description": "의존성 설치가 진행되는 동안 사용자에게 스피너를 보여주어 작업이 진행 중임을 알리고, 완료 또는 실패 시 적절한 메시지를 출력합니다.",
            "dependencies": [
              3,
              4
            ],
            "details": "CLI 도구에 `ora` 라이브러리를 설치합니다. `installDependencies` 함수 내에서 `execa` 호출 전후로 `ora` 스피너를 시작하고(`spinner.start('Installing additional dependencies...')`), 성공 시 `spinner.succeed()`, 실패 시 `spinner.fail()`을 호출하도록 코드를 수정합니다.",
            "status": "pending",
            "testStrategy": "수동 테스트를 통해 의존성 설치 중에 스피너가 정상적으로 표시되고, 설치 완료 후 성공 메시지가 나타나는지 확인합니다. 의도적으로 설치를 실패시켜 실패 메시지가 올바르게 표시되는지도 검증합니다."
          }
        ]
      },
      {
        "id": 16,
        "title": "공통 설정 파일(ESLint, Prettier, .vscode) 자동 생성",
        "description": "팀의 개발 표준을 강제하기 위해 ESLint, Prettier, Cursor/VSCode 에디터 설정 파일을 자동으로 생성하고 프로젝트에 주입합니다.",
        "details": "미리 정의된 `.eslintrc.cjs`, `.prettierrc`, `.vscode/settings.json` 파일을 템플릿의 일부로 포함시킵니다. `settings.json`에는 'editor.formatOnSave: true' 및 'editor.defaultFormatter'와 같은 공통 규칙과 Cursor 전용 룰을 포함합니다. 이 파일들은 템플릿 복제 시점에 함께 대상 프로젝트로 복사됩니다.",
        "testStrategy": "프로젝트 생성 후, 해당 설정 파일들(`.eslintrc.cjs`, `.prettierrc`, `.vscode/settings.json`)이 올바른 내용으로 존재하는지 확인합니다. 생성된 프로젝트에서 `npx eslint . --max-warnings 0` 및 `npx prettier --check .` 명령어를 실행하여 코드 스타일 규칙이 즉시 적용되고 통과하는지 검증합니다.",
        "priority": "medium",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "공통 설정 파일을 위한 템플릿 디렉터리 구조 생성",
            "description": "새 프로젝트에 복사될 ESLint, Prettier, VSCode 설정 파일을 저장할 `templates/common` 디렉터리 구조를 CLI 프로젝트 내에 생성합니다.",
            "dependencies": [],
            "details": "CLI 프로젝트의 루트 레벨에 `templates` 디렉터리를 생성하고, 그 안에 `common` 이라는 하위 디렉터리를 만듭니다. 또한, VSCode 설정 파일을 위해 `templates/common/.vscode` 디렉터리도 함께 생성합니다.",
            "status": "pending",
            "testStrategy": "프로젝트 루트에서 `test -d templates/common && test -d templates/common/.vscode` 쉘 명령어를 실행하여 디렉터리들이 정상적으로 생성되었는지 확인합니다."
          },
          {
            "id": 2,
            "title": "ESLint 설정 파일(.eslintrc.cjs) 템플릿 생성",
            "description": "팀의 표준 JavaScript/TypeScript 린팅 규칙을 포함하는 `.eslintrc.cjs` 파일을 `templates/common` 디렉터리에 생성합니다.",
            "dependencies": [
              1
            ],
            "details": "`@typescript-eslint/parser`, `eslint-plugin-react`, `eslint-config-prettier` 등을 포함하는 표준 규칙셋으로 `.eslintrc.cjs` 파일을 작성합니다. 이 파일은 `templates/common` 디렉터리에 위치해야 합니다.",
            "status": "pending",
            "testStrategy": "임시 테스트 프로젝트에 해당 설정 파일을 복사한 후 `npx eslint . --max-warnings 0` 명령을 실행하여 오류 없이 통과하는지 검증합니다."
          },
          {
            "id": 3,
            "title": "Prettier 설정 파일(.prettierrc) 템플릿 생성",
            "description": "일관된 코드 포맷팅 스타일을 강제하기 위한 `.prettierrc` 설정 파일을 `templates/common` 디렉터리에 생성합니다.",
            "dependencies": [
              1
            ],
            "details": "`templates/common` 디렉터리 내에 `.prettierrc` 파일을 생성하고, `singleQuote: true`, `semi: true`, `tabWidth: 2`, `trailingComma: 'all'` 과 같은 팀 표준 포맷팅 옵션을 JSON 형식으로 정의합니다.",
            "status": "pending",
            "testStrategy": "임의의 코드 파일에 대해 `npx prettier --check .` 명령어를 실행하여 포맷팅 규칙 위반이 없는지 확인하고, `--write` 옵션으로 파일이 올바르게 수정되는지 검증합니다."
          },
          {
            "id": 4,
            "title": "VSCode/Cursor 에디터 설정 파일(settings.json) 템플릿 생성",
            "description": "'저장 시 자동 포맷'과 같은 개발 생산성 향상 설정을 포함하는 `.vscode/settings.json` 파일을 생성합니다.",
            "dependencies": [
              1
            ],
            "details": "`templates/common/.vscode` 디렉터리 내에 `settings.json` 파일을 생성합니다. 파일 내용에는 `\"editor.formatOnSave\": true`, `\"editor.defaultFormatter\": \"esbenp.prettier-vscode\"` 등의 규칙을 반드시 포함합니다.",
            "status": "pending",
            "testStrategy": "생성된 프로젝트를 VSCode로 열고, 파일을 수정한 뒤 저장(Ctrl+S)했을 때 Prettier에 의해 코드가 자동으로 포맷팅되는지 수동으로 확인합니다."
          },
          {
            "id": 5,
            "title": "프로젝트 생성 시 템플릿 파일 복사 로직 구현",
            "description": "`create <project-name>` 명령어 실행 시 `templates/common` 디렉터리의 모든 설정 파일을 생성될 프로젝트의 루트로 복사하는 기능을 구현합니다.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "CLI의 프로젝트 생성 로직(commander.js의 action 콜백)에 `fs-extra` 라이브러리의 `copy` 함수를 사용하여 `templates/common`의 내용물을 사용자가 지정한 새 프로젝트 폴더로 재귀적으로 복사하는 코드를 추가합니다.",
            "status": "pending",
            "testStrategy": "CLI를 실행하여 새 프로젝트를 생성한 후, 생성된 프로젝트 디렉터리 내에 `.eslintrc.cjs`, `.prettierrc`, `.vscode/settings.json` 파일이 모두 존재하는지 파일 시스템을 통해 확인합니다."
          }
        ]
      },
      {
        "id": 17,
        "title": "README.md 내용 동적 생성 및 요약 추가",
        "description": "사용자가 선택한 옵션(상태 관리, 스타일링 등)에 대한 요약과 Taskmaster 사용법 안내를 포함하여 README.md 파일을 동적으로 생성합니다.",
        "details": "기본적인 프로젝트 구조와 실행 명령어가 포함된 `README.template.md` 파일을 준비합니다. EJS나 Handlebars와 같은 템플릿 엔진을 사용하여 `<%= options.stateManagement %>`와 같은 플레이스홀더를 둡니다. 프로젝트 생성 과정에서 수집한 옵션 객체를 이 템플릿에 주입하여 최종 `README.md` 파일을 생성합니다. Taskmaster 설치 옵션이 활성화된 경우, 관련 사용법 섹션을 조건부로 렌더링합니다.",
        "testStrategy": "다양한 옵션 조합으로 프로젝트를 생성하고, 각 경우에 생성된 `README.md` 파일의 내용이 선택된 옵션을 정확하게 반영하는지 스냅샷 테스트(snapshot testing)를 통해 검증합니다. 링크나 명령어 등이 올바르게 생성되었는지도 확인합니다.",
        "priority": "medium",
        "dependencies": [
          14,
          15
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "EJS 템플릿 엔진 의존성 추가",
            "description": "README.md 파일의 동적 생성을 위해 필요한 EJS 템플릿 엔진을 프로젝트의 의존성으로 추가합니다.",
            "dependencies": [],
            "details": "npm install ejs 또는 yarn add ejs 명령어를 사용하여 `package.json`의 `dependencies`에 ejs를 추가합니다. 타입스크립트 지원을 위해 `@types/ejs`를 `devDependencies`에 추가하는 것도 포함합니다.",
            "status": "pending",
            "testStrategy": "의존성 설치 후 `npm install` 또는 `yarn`을 실행했을 때 오류가 발생하지 않는지 확인하고, `node_modules`에 `ejs` 폴더가 생성되었는지 확인합니다."
          },
          {
            "id": 2,
            "title": "`README.template.md` 파일 생성 및 기본 구조 작성",
            "description": "동적으로 내용이 채워질 README의 기반이 되는 템플릿 파일을 생성합니다. 이 파일에는 프로젝트 제목, 설명, 실행 명령어 등 공통적인 섹션이 포함됩니다.",
            "dependencies": [],
            "details": "`templates` 디렉토리 또는 적절한 위치에 `README.template.md` 파일을 생성합니다. 프로젝트 이름(<%= projectName %>), 기본 스크립트(npm install, npm run dev) 등의 정적 내용과 플레이스홀더를 포함하여 마크다운 구조를 작성합니다.",
            "status": "pending",
            "testStrategy": "파일이 올바른 경로에 생성되었는지, 기본적인 마크다운 문법이 유효한지 수동으로 확인합니다."
          },
          {
            "id": 3,
            "title": "README 생성 및 템플릿-데이터 주입 로직 구현",
            "description": "사용자로부터 입력받은 옵션 객체(데이터)와 `README.template.md` 파일(템플릿)을 조합하여 최종 `README.md` 파일을 생성하는 함수를 구현합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "`src/main.ts` 또는 별도의 유틸리티 파일에 `generateReadme(targetDir, options)`와 같은 함수를 작성합니다. 이 함수는 EJS의 `renderFile` 또는 `render` 메소드를 사용하여 `options` 객체를 템플릿에 주입하고, 결과를 `targetDir` 내의 `README.md` 파일로 저장합니다.",
            "status": "pending",
            "testStrategy": "단위 테스트를 통해 `options` 객체가 주어졌을 때 예상되는 `README.md` 문자열이 정상적으로 생성되는지 검증합니다."
          },
          {
            "id": 4,
            "title": "메인 생성 파이프라인에 README 생성 로직 통합",
            "description": "프로젝트 생성 과정의 적절한 시점에 `generateReadme` 함수를 호출하여, 전체 프로세스에 동적 README 생성 기능을 통합합니다.",
            "dependencies": [
              3
            ],
            "details": "`src/main.ts`의 `createProject` 함수 내에서 파일 복사가 완료된 후, `npm install`이 실행되기 전에 `generateReadme` 함수를 호출하도록 코드를 추가합니다. 사용자 옵션과 생성될 프로젝트 경로를 인자로 전달합니다.",
            "status": "pending",
            "testStrategy": "CLI를 직접 실행하여 프로젝트를 생성했을 때, `README.md` 파일이 정상적으로 생성되고 그 내용에 기본 옵션들이 반영되었는지 확인합니다."
          },
          {
            "id": 5,
            "title": "Taskmaster 사용법 안내 섹션 조건부 렌더링 구현",
            "description": "사용자가 Taskmaster 설치를 선택한 경우에만 README에 Taskmaster 관련 사용법 안내 섹션이 포함되도록 템플릿에 조건부 로직을 추가합니다.",
            "dependencies": [
              2,
              3
            ],
            "details": "`README.template.md` 파일 내에 EJS의 조건문(<% if (options.taskmaster) { %> ... <% } %>)을 사용합니다. `options.taskmaster` 값이 true일 때만 'Taskmaster 사용법' 섹션이 렌더링되도록 구현합니다.",
            "status": "pending",
            "testStrategy": "Taskmaster 옵션을 활성화했을 때와 비활성화했을 때 각각 프로젝트를 생성하여, 생성된 `README.md` 파일에 해당 섹션이 올바르게 포함되거나 제외되는지 스냅샷 테스트 또는 수동으로 비교 검증합니다."
          }
        ]
      },
      {
        "id": 18,
        "title": "핵심 유틸리티(로깅, 파일 시스템)에 대한 유닛 테스트 작성",
        "description": "파일 복사, 디렉터리 생성, 옵션 파싱 등 재사용 가능한 핵심 유틸리티 함수들에 대한 유닛 테스트를 작성하여 CLI의 안정성과 신뢰도를 높입니다.",
        "details": "`vitest`를 테스트 프레임워크로 사용합니다. 파일 시스템에 의존하는 함수의 경우, `memfs`와 같은 인메모리 파일 시스템 라이브러리를 사용하여 실제 디스크 I/O 없이 빠르고 격리된 테스트를 수행합니다. 로깅 유틸리티는 `console.log`를 스파이(spy)하여 특정 메시지가 올바른 형식으로 출력되는지 검증합니다.",
        "testStrategy": "`npm run test` 명령을 실행하여 모든 유닛 테스트가 통과하는지 확인합니다. `vitest`의 커버리지 리포트 기능을 활성화하여 주요 로직의 테스트 커버리지가 목표 수준(예: 80%) 이상인지 지속적으로 관리합니다.",
        "priority": "medium",
        "dependencies": [
          11,
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Vitest 테스트 환경 설정 및 `memfs` 통합",
            "description": "파일 시스템에 의존하는 유틸리티 함수들을 격리된 환경에서 테스트하기 위해 Vitest 테스트 프레임워크를 설정하고, `memfs`를 이용한 인메모리 파일 시스템을 연동합니다. 이는 실제 디스크 I/O를 방지하여 빠르고 안정적인 테스트를 보장합니다.",
            "dependencies": [],
            "details": "`vitest`와 `memfs` 라이브러리를 devDependencies에 추가합니다. `vitest.config.ts` 파일에서 테스트 환경 설정을 완료하고, `fs` 모듈을 `memfs`로 모킹(mocking)하는 테스트 설정 또는 헬퍼 파일을 작성하여 파일 시스템 테스트를 위한 기반을 마련합니다.",
            "status": "pending",
            "testStrategy": "테스트 실행 시 실제 파일 시스템이 아닌 `memfs`의 가상 파일 시스템을 사용하는지 확인하기 위해 간단한 파일 생성/읽기 테스트를 작성하여 검증합니다."
          },
          {
            "id": 2,
            "title": "로깅 유틸리티(`utils/logger.ts`)에 대한 유닛 테스트 작성",
            "description": "사용자에게 상태를 알려주는 로깅 유틸리티(info, success, error 등)가 정확한 메시지와 스타일로 출력되는지 검증하는 테스트 스위트를 작성합니다.",
            "dependencies": [],
            "details": "`vitest`의 `vi.spyOn` 기능을 사용하여 `console.log`, `console.error` 등의 전역 객체를 감시합니다. 각 로깅 함수(예: `logger.info()`, `logger.error()`)를 호출했을 때, 스파이가 올바른 인자(색상 코드가 포함된 문자열 등)로 호출되었는지 `toHaveBeenCalledWith`를 사용하여 검증합니다.",
            "status": "pending",
            "testStrategy": "각 로그 레벨(info, success, error, warn)에 대한 테스트 케이스를 작성하고, 포맷팅된 출력 메시지가 예상과 정확히 일치하는지 스파이 객체를 통해 확인합니다."
          },
          {
            "id": 3,
            "title": "파일 시스템 유틸리티 - 디렉터리 생성 함수 테스트",
            "description": "프로젝트 디렉터리를 생성하는 유틸리티 함수(예: `createProjectDirectory`)에 대한 유닛 테스트를 작성합니다. 이미 디렉터리가 존재하는 경우나 유효하지 않은 경로 같은 엣지 케이스를 포함하여 안정성을 검증합니다.",
            "dependencies": [
              1
            ],
            "details": "`memfs`로 초기화된 가상 파일 시스템 상에서 디렉터리 생성 함수를 실행합니다. 테스트 실행 후, `memfs`의 `fs.existsSync`나 `fs.readdirSync`를 사용해 지정된 경로에 디렉터리가 올바르게 생성되었는지 확인합니다. 디렉터리가 이미 존재할 때 에러를 발생시키는 로직도 테스트합니다.",
            "status": "pending",
            "testStrategy": "1) 새 디렉터리 생성 성공, 2) 이미 존재하는 디렉터리 시도 시 예외 처리, 3) 중첩된 경로에 디렉터리 생성 등 다양한 시나리오를 테스트 케이스로 작성하여 검증합니다."
          },
          {
            "id": 4,
            "title": "파일 시스템 유틸리티 - 템플릿 복사 함수(`copyTemplateFiles`) 테스트",
            "description": "프로젝트 템플릿 파일들을 대상 디렉터리로 복사하는 핵심 로직에 대한 유닛 테스트를 작성합니다. 재귀적 복사 및 파일 내용의 정확성을 검증합니다.",
            "dependencies": [
              1
            ],
            "details": "`memfs`를 사용하여 가상의 'templates' 디렉터리와 그 안에 여러 파일 및 하위 디렉터리를 구성합니다. 템플릿 복사 함수를 실행한 후, 생성된 프로젝트 디렉터리의 구조와 각 파일의 내용이 원본 템플릿과 일치하는지 `memfs`의 API를 통해 비교하고 검증합니다.",
            "status": "pending",
            "testStrategy": "가상 파일 시스템에서 소스 템플릿과 복사된 결과물의 디렉터리 구조 및 파일 내용을 비교하여 일치 여부를 확인합니다. `.gitignore`와 같이 이름이 변경되어야 하는 파일의 처리 로직도 함께 테스트합니다."
          },
          {
            "id": 5,
            "title": "CLI 옵션 파싱 및 유효성 검사 로직 테스트",
            "description": "CLI에 전달된 인자(예: 프로젝트 이름)를 파싱하고 유효성을 검사하는 로직에 대한 유닛 테스트를 작성합니다. 유효하지 않은 프로젝트 이름이 입력되었을 때 적절한 오류를 반환하는지 확인합니다.",
            "dependencies": [],
            "details": "`commander.js`에 의존하는 액션 핸들러 함수를 테스트합니다. `process.argv`를 모킹하여 다양한 CLI 입력(예: `['node', 'index.js', 'my-app']`, `['node', 'index.js', '']`)을 시뮬레이션하고, 파싱된 인자가 액션 핸들러에 정확히 전달되는지 확인합니다. 유효성 검사 함수를 직접 호출하여 테스트할 수도 있습니다.",
            "status": "pending",
            "testStrategy": "유효한 프로젝트 이름, 유효하지 않은 이름(특수문자 포함 등), 이름이 없는 경우 등 다양한 입력 값에 대한 테스트 케이스를 작성하여 각 경우에 예상된 동작(성공 또는 에러)이 발생하는지 검증합니다."
          }
        ]
      },
      {
        "id": 19,
        "title": "상태 관리 라이브러리(Jotai, Zustand) 옵션 분기 처리",
        "description": "사용자가 프롬프트에서 'jotai' 또는 'zustand'를 선택했을 때, 해당 라이브러리를 설치하고 기본 사용 예시 코드를 템플릿에 추가하는 로직을 구현합니다.",
        "details": "옵션별 코드 조각을 `templates/addons/jotai` 및 `templates/addons/zustand`와 같은 별도 디렉터리에 관리합니다. 사용자가 특정 상태 관리 라이브러리를 선택하면, 의존성 설치 단계에서 해당 패키지를 추가하고, 파일 복제 단계 이후에 해당 `addons` 디렉터리의 파일(예: `src/store/counter.ts`)을 생성된 프로젝트에 병합합니다.",
        "testStrategy": "1) jotai 선택, 2) zustand 선택, 3) 선택 안 함 세 가지 경우를 모두 테스트합니다. 각 시나리오별로 `package.json`의 의존성 목록과 `src/store` 폴더 내의 파일 존재 여부 및 내용이 예상과 일치하는지 확인합니다.",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "상태 관리 라이브러리 선택을 위한 프롬프트 추가",
            "description": "사용자가 어떤 상태 관리 라이브러리를 사용할지 (Jotai, Zustand, 없음) 선택할 수 있도록 CLI에 프롬프트를 추가합니다.",
            "dependencies": [],
            "details": "`inquirer` 또는 유사한 프롬프트 라이브러리를 사용하여, 'stateManagement' 옵션을 받는 질문을 추가합니다. 선택지는 'none', 'jotai', 'zustand' 세 가지를 제공해야 합니다. 사용자의 선택은 후속 처리 단계에서 사용할 수 있도록 변수에 저장됩니다.",
            "status": "pending",
            "testStrategy": "CLI를 실행했을 때 상태 관리 라이브러리 선택 프롬프트가 정상적으로 표시되는지, 그리고 각 옵션을 선택했을 때 다음 단계로 올바른 값이 전달되는지 확인합니다."
          },
          {
            "id": 2,
            "title": "Jotai 애드온 템플릿 파일 및 디렉터리 구조 생성",
            "description": "Jotai를 선택했을 때 프로젝트에 추가될 기본 예제 코드와 파일 구조를 생성합니다.",
            "dependencies": [],
            "details": "`templates/addons/jotai/src/store` 디렉터리를 생성하고, 내부에 간단한 카운터 상태를 관리하는 `counter.ts` 파일을 추가합니다. 파일에는 `atom`을 사용한 기본 상태 정의와 export가 포함되어야 합니다.",
            "status": "pending",
            "testStrategy": "`templates/addons/jotai/src/store/counter.ts` 파일이 생성되었는지, 그리고 파일 내용이 유효한 Jotai 코드인지 수동으로 검토합니다."
          },
          {
            "id": 3,
            "title": "Zustand 애드온 템플릿 파일 및 디렉터리 구조 생성",
            "description": "Zustand를 선택했을 때 프로젝트에 추가될 기본 예제 코드와 파일 구조를 생성합니다.",
            "dependencies": [],
            "details": "`templates/addons/zustand/src/store` 디렉터리를 생성하고, 내부에 간단한 카운터 상태를 관리하는 `counter.ts` 파일을 추가합니다. 파일에는 `create` 함수를 사용한 기본 스토어 생성 코드가 포함되어야 합니다.",
            "status": "pending",
            "testStrategy": "`templates/addons/zustand/src/store/counter.ts` 파일이 생성되었는지, 그리고 파일 내용이 유효한 Zustand 코드인지 수동으로 검토합니다."
          },
          {
            "id": 4,
            "title": "선택된 라이브러리에 따른 의존성 동적 추가 로직 구현",
            "description": "사용자의 프롬프트 선택에 따라 생성될 프로젝트의 `package.json` 파일에 'jotai' 또는 'zustand' 의존성을 동적으로 추가합니다.",
            "dependencies": [
              1
            ],
            "details": "프로젝트 생성 과정 중, 프롬프트에서 저장된 'stateManagement' 값을 확인합니다. 값이 'jotai' 또는 'zustand'일 경우, 생성될 프로젝트의 `package.json` 파일을 읽어 `dependencies` 객체에 해당 라이브러리를 추가한 후 다시 저장하는 함수를 구현합니다.",
            "status": "pending",
            "testStrategy": "Jotai와 Zustand를 각각 선택하여 프로젝트를 생성한 후, 최종 `package.json` 파일의 'dependencies'에 해당 라이브러리가 올바른 버전으로 추가되었는지 확인합니다. 'none'을 선택했을 때는 추가되지 않는지도 확인합니다."
          },
          {
            "id": 5,
            "title": "선택된 라이브러리 애드온 파일 복사 로직 구현",
            "description": "사용자가 선택한 상태 관리 라이브러리에 해당하는 템플릿 파일을 생성된 프로젝트 디렉터리로 복사하는 로직을 구현합니다.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "기본 템플릿 복사가 완료된 후, 'stateManagement' 옵션 값을 확인하는 조건문을 추가합니다. 'jotai'가 선택된 경우 `templates/addons/jotai/`의 내용을, 'zustand'가 선택된 경우 `templates/addons/zustand/`의 내용을 생성된 프로젝트 경로에 재귀적으로 복사/병합합니다.",
            "status": "pending",
            "testStrategy": "Jotai와 Zustand를 각각 선택하여 프로젝트를 생성한 후, `src/store/counter.ts` 파일이 올바른 내용으로 생성되었는지 확인합니다. 'none'을 선택했을 때는 해당 디렉터리 및 파일이 생성되지 않아야 합니다."
          }
        ]
      },
      {
        "id": 20,
        "title": "CLI 종단간(E2E) 테스트 자동화 구축",
        "description": "CLI 실행부터 프로젝트 생성, 의존성 설치, 기본 테스트 실행까지 전체 사용자 플로우를 검증하는 자동화된 E2E 테스트를 구축하여 릴리스 안정성을 확보합니다.",
        "details": "Node.js 스크립트 또는 쉘 스크립트를 사용하여 E2E 테스트를 작성합니다. 이 스크립트는 `execa`를 통해 `create-vitnal` 명령을 비동기적으로 실행하고, `inquirer` 프롬프트가 나타날 때 표준 입력(stdin)을 통해 미리 정의된 답변(예: 엔터키 연타로 기본값 선택)을 전달합니다. 생성 완료 후, 생성된 프로젝트 디렉터리로 이동하여 `npm install`, `npm run build`, `npm run test`를 순차적으로 실행하고 모든 명령이 성공 코드(0)로 종료되는지 확인합니다.",
        "testStrategy": "E2E 테스트 스크립트를 로컬 환경에서 실행하여 전체 파이프라인이 정상 동작하는지 확인합니다. GitHub Actions와 같은 CI 환경에 이 테스트 스크립트를 연동하여, 코드 푸시 또는 Pull Request 시 자동으로 실행되도록 설정합니다. 테스트 실패 시 빌드가 중단되고 알림을 받도록 구성합니다.",
        "priority": "low",
        "dependencies": [
          17,
          18
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "E2E 테스트 환경 설정 및 의존성 설치",
            "description": "E2E 테스트 실행을 위한 기본 환경을 구축합니다. `execa`와 파일 시스템 관리를 위한 `fs-extra` 같은 개발 의존성을 설치하고, 테스트 결과를 임시 디렉터리에 생성하도록 기본 스크립트 구조를 잡습니다.",
            "dependencies": [],
            "details": "`package.json`의 `devDependencies`에 `execa`, `fs-extra`를 추가합니다. `scripts/e2e` 디렉터리를 생성하고, 테스트 실행 시 생성될 프로젝트를 저장할 임시 디렉터리(예: `temp-e2e-project`)를 만들고 비우는 로직을 포함하는 기본 테스트 스크립트 파일(예: `run-e2e.mjs`)을 작성합니다.",
            "status": "pending",
            "testStrategy": "`npm install`을 실행하여 새 의존성이 정상적으로 설치되는지 확인하고, 스크립트 실행 시 임시 디렉터리가 생성되는지 수동으로 확인합니다."
          },
          {
            "id": 2,
            "title": "`create-vitnal` 프로세스 실행 및 프롬프트 입력 자동화",
            "description": "`execa`를 사용하여 `create-vitnal` CLI 명령어를 자식 프로세스로 실행합니다. `inquirer` 프롬프트가 표시될 때, stdin 스트림에 엔터 키 입력을 보내 모든 질문에 기본값으로 응답하도록 자동화 로직을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "`execa`를 사용하여 `node dist/index.js create-vitnal-e2e-test`와 같은 명령을 실행합니다. 자식 프로세스의 `stdin.write('\\n')`을 사용하여 각 프롬프트에 엔터 키를 전송합니다. 프로세스가 성공적으로 종료(exit code 0)되는지 확인합니다.",
            "status": "pending",
            "testStrategy": "스크립트를 실행하여 `temp-e2e-project` 디렉터리에 기본 옵션으로 프로젝트가 실제로 생성되는지 확인합니다. CLI의 출력 로그를 검사하여 오류가 없는지 확인합니다."
          },
          {
            "id": 3,
            "title": "생성된 프로젝트의 기본 파일 구조 검증",
            "description": "`create-vitnal` 실행 완료 후, 생성된 프로젝트 디렉터리 내에 `package.json`, `vite.config.ts`, `src/main.tsx` 등 필수 파일들이 정상적으로 존재하는지 확인하는 검증 단계를 추가합니다.",
            "dependencies": [
              2
            ],
            "details": "`fs.existsSync`와 같은 Node.js 파일 시스템 모듈을 사용하여 필수 파일 및 디렉터리 목록(예: `['package.json', 'vite.config.ts', 'src', 'src/App.tsx']`)이 모두 존재하는지 확인하는 함수를 구현합니다. 파일이 누락된 경우 테스트를 실패 처리합니다.",
            "status": "pending",
            "testStrategy": "의도적으로 템플릿에서 파일을 삭제한 후 테스트를 실행하여, 파일 누락 시 테스트가 올바르게 실패하는지 확인합니다. 정상적인 경우에는 테스트가 통과해야 합니다."
          },
          {
            "id": 4,
            "title": "생성된 프로젝트 내에서 `install`, `build`, `test` 명령어 실행",
            "description": "생성된 프로젝트 디렉터리로 이동하여 `npm install`, `npm run build`, `npm run test` 명령어를 순차적으로 실행합니다. 각 명령어가 오류 없이 성공적으로 완료되는지(exit code 0) 확인합니다.",
            "dependencies": [
              3
            ],
            "details": "`execa`를 다시 사용하되, `cwd` 옵션을 생성된 프로젝트 경로로 설정하여 명령어를 실행합니다. `npm install` 후 `npm run build`를 실행하고, 마지막으로 `npm run test`를 실행합니다. 각 단계에서 Promise가 reject되거나 exit code가 0이 아니면 테스트를 즉시 실패시킵니다.",
            "status": "pending",
            "testStrategy": "각 명령어가 실행될 때 출력되는 로그를 확인하여 정상적으로 진행되는지 모니터링합니다. 최종적으로 모든 명령어가 성공적으로 완료되면 테스트가 통과하는지 확인합니다."
          },
          {
            "id": 5,
            "title": "E2E 테스트 스크립트 통합 및 `package.json`에 등록",
            "description": "모든 단계를 하나의 E2E 테스트 스크립트로 통합하고, 테스트 성공/실패 여부와 관계없이 생성된 임시 프로젝트 디렉터리를 삭제하는 정리(cleanup) 로직을 추가합니다. `package.json`에 `test:e2e` 스크립트를 추가하여 쉽게 실행할 수 있도록 합니다.",
            "dependencies": [
              4
            ],
            "details": "`try...finally` 블록을 사용하여 테스트 로직을 `try` 안에 배치하고, `finally` 블록에서 `fs.removeSync`를 사용하여 임시 디렉터리를 삭제합니다. `package.json`의 `scripts`에 `\"test:e2e\": \"node scripts/e2e/run-e2e.mjs\"`를 추가합니다.",
            "status": "pending",
            "testStrategy": "`npm run test:e2e` 명령을 실행하여 전체 파이프라인이 동작하는지 확인합니다. 테스트가 끝난 후 임시 프로젝트 폴더가 깨끗하게 삭제되었는지 파일 시스템에서 확인합니다."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-11-11T14:24:02.818Z",
      "updated": "2025-11-11T19:44:40.924Z",
      "description": "Tasks for master context"
    }
  }
}